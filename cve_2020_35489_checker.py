# Native Python libraries
import argparse
import asyncio
import os

# External libraries
import aiofiles
import aiohttp
from packaging import version


async def detect_plugin_version(readme):
    """
    Detects the version of a plugin based on the provided readme text.

    Args:
        readme (str): The readme text of the plugin.

    Returns:
        str or None: The detected version of the plugin if found, None otherwise.
    """
    # Localize the line with the plugin version.
    start_tag = "Stable tag:"
    version_start_index = readme.find(start_tag)

    # Raise an error if the line with the version is not found.
    if version_start_index == -1:
        raise KeyError("Invalid readme format or 'Stable tag:' not found.")

    # Detect the end of the line for the plugin version.
    version_end_index = readme.find("\n", version_start_index)

    # Raise an error if no line break is found after the version.
    if version_end_index == -1:
        raise IndexError("Invalid readme format or Line break after version not found.")

    # Extract the version of the plugin from the readme text.
    # Get the substring between the "Stable tag:" start tag and the line break.
    version_substring = readme[version_start_index + len(start_tag):version_end_index].strip()

    # Return None if the substring is empty.
    if not version_substring:
        return None

    # Extract the first word as the detected version.
    plugin_version = version_substring.partition(" ")[0]

    return plugin_version


async def check_site(session, domain, output_file):
    """
    Checks a site for vulnerabilities related to the Contact Form 7 plugin.

    Args:
        session (aiohttp.ClientSession): An instance of `aiohttp.ClientSession` for making HTTP requests.
        domain (str): The domain of the site to be checked.
        output_file (str): The file path to store the list of vulnerable sites.

    Raises:
        asyncio.TimeoutError: If the request to retrieve the plugin version exceeds the timeout.
        ValueError: If an error occurs while obtaining the plugin version.
    """
    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"
    }
    plugin_url = f'https://{domain}/wp-content/plugins/contact-form-7/readme.txt'

    try:
        async with session.get(plugin_url, headers=headers, timeout=3, ssl=False) as response:
            if response.status == 200:
                plugin_version = await detect_plugin_version(await response.text())

                is_vulnerable = version.parse(plugin_version) < version.parse("5.3.2")
                print(f"\nSite: {domain}\nPlugin Version \"Contact Form 7\": {plugin_version}")
                print(f"{domain} {'-----------------------------------------------------------> ' if is_vulnerable else ' :( NOT '}VULNERABLE!\n")
                if output_file and is_vulnerable:
                    async with aiofiles.open(output_file, "a") as f:
                        await f.write(f"{domain}\n")
            else:
                print(f"\nSite: {domain}\nFailed to make an HTTP request to retrieve the plugin version:\nStatus code: {response.status}")
    except asyncio.TimeoutError:
        print(f"\nSite: {domain}\nFailure: The request to retrieve the plugin version exceeded the timeout. (3 seconds)\n")
    except Exception as e:
        print(f"\nSite: {domain}\nAn error occurred while obtaining the plugin version:\n{str(e)}\n")


async def main():
    """
    Checks if WordPress websites are vulnerable to CVE-2020-35489.

    The function accepts command-line arguments to specify the sites to check. It supports checking a single site
    using the '-d' or '--domain' option, or checking multiple sites from a text file using the '-i' or '--input-file'
    option. The results can be optionally saved to a file specified by the '-o' or '--output-file' option.

    Example usage:
    - Check a single site:
      python cve_2020_35489_checker.py -d example.com

    - Check multiple sites from a text file:
      python cve_2020_35489_checker.py -i list.txt -o vulnerable.txt

    Args:
        None

    Returns:
        None
    """
    parser = argparse.ArgumentParser(
        description='Checks if a WordPress website is vulnerable to CVE-2020-35489.'
    )
    parser.add_argument('-d', '--domain', help='Check a single site (Example: python cve_2020_35489_checker.py -d example.com)')
    parser.add_argument('-i', '--input-file', help='Check multiple sites from a text file (Example: python cve_2020_35489_checker.py -i list.txt -o vulnerable.txt)')
    parser.add_argument('-o', '--output-file', help='Output file for the list of vulnerable sites')
    args = parser.parse_args()

    if args.output_file and not os.path.exists(args.output_file):
        open(args.output_file, 'w').close()

    if args.input_file:
        if not os.path.exists(args.input_file):
            open(args.input_file, 'w').close()
            print(f"The input file '{args.input_file}' is created, but it is empty. Please populate it with a list of sites to test.")
        else:
            async with aiohttp.ClientSession() as session:
                async with aiofiles.open(args.input_file, 'r') as f:
                    lines = await f.readlines()
                    tasks = [
                        check_site(session, line.strip().split(':')[0], args.output_file)
                        for line in lines if line.strip()
                    ]
                    await asyncio.gather(*tasks)
    elif args.domain:
        async with aiohttp.ClientSession() as session:
            await check_site(session, args.domain, args.output_file)
    else:
        parser.print_help()


asyncio.run(main())