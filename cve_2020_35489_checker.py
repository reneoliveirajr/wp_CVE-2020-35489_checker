import argparse
import asyncio
import os
import aiofiles
import aiohttp
from packaging import version


async def detect_plugin_version(readme):
    """
    Detects the version of a plugin based on the provided readme text.

    Args:
        readme (str): The readme text of the plugin.

    Returns:
        str: The detected version of the plugin.

    Raises:
        KeyError: If the line with the version is not found in the readme.
        IndexError: If no line break is found after the version in the readme.
        ValueError: If the plugin version is missing or empty.

    Note:
        The function assumes that the version line in the readme has the format
        "Stable tag: <version>". If the format differs, the function may not work
        correctly.
    """
 
    # Localize the line with the plugin version
    start_tag = "Stable tag: "
    version_start_index = readme.find(start_tag)

    # Raise an error if the line with the version is not found
    if version_start_index == -1:
        raise KeyError("Invalid readme format or 'Stable tag:' not found.")

    # Detect the end of the line for the plugin version
    version_end_index = readme.find("\n", version_start_index)

    # Raise an error if no line break is found after the version
    if version_end_index == -1:
        raise IndexError("Invalid readme format or Line break after version not found.")

    # Extract the version of the plugin from the readme text
    # Get the substring between the "Stable tag: " start tag and the line break
    plugin_version = readme[version_start_index + len(start_tag):version_end_index]

    # Raise an error if the substring is empty
    if not plugin_version:
        raise ValueError("Plugin version is missing or empty.")

    return plugin_version


def format_domain(domain):
    """
    Format domain string to deal with just domain or full (with http://) URL cases.

    Args:
        domain (str): The domain of the site to be formated.

    Returns:
        str: Formated domain URL. Returns the input string unchanged if it already starts with 'http',
        otherwise prepends 'https://' to the input string and returns it.
    """

    if domain.startswith("http"):
        return domain
    else:
        return f"https://{domain}"


async def check_site(session, domain, output_file):
    """
    Checks a site for vulnerabilities related to the Contact Form 7 plugin.

    Args:
        session (aiohttp.ClientSession): An instance of `aiohttp.ClientSession` for making HTTP requests.
        domain (str): The domain of the site to be checked.
        output_file (str): The file path to store the list of vulnerable sites.

    Raises:
        asyncio.TimeoutError: If the request to retrieve the plugin version exceeds the timeout.
        ValueError: If an error occurs while obtaining the plugin version.
    """

    headers = {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0"
    }
    
    domain = format_domain(domain)
    plugin_url = f"{domain}/wp-content/plugins/contact-form-7/readme.txt"

    try:
        async with session.get(plugin_url, headers=headers, timeout=3, ssl=False) as response:
            if response.status == 200:
                plugin_version = await detect_plugin_version(await response.text())

                is_vulnerable = version.parse(plugin_version) < version.parse("5.3.2")
                print(f"\nSite: {domain}\nContact Form 7 Plugin Version: {plugin_version}")
                print(f"{domain} {'-----------------------------------------------------------> ' if is_vulnerable else ' :( NOT '}VULNERABLE!\n")
                if output_file and is_vulnerable:
                    async with aiofiles.open(output_file, "a") as f:
                        await f.write(f"Site: {domain}\nContact Form 7 Plugin Version: {plugin_version}\n\n")
            else:
                print(f"\nSite: {domain}\nFailed to make an HTTP request to retrieve the plugin version:\nStatus code: {response.status}")
    except asyncio.TimeoutError:
        print(f"\nSite: {domain}\nFailure: The request to retrieve the plugin version exceeded the timeout. (3 seconds)\n")
    except Exception as e:
        print(f"\nSite: {domain}\nAn error occurred while obtaining the plugin version:\n{str(e)}\n")


async def main():
    """
    Checks if WordPress websites are vulnerable to CVE-2020-35489.

    The function accepts command-line arguments to specify the sites to check. It supports checking a single site
    using the '-d' or '--domain' option, or checking multiple sites from a text file using the '-i' or '--input-file'
    option. The results can be optionally saved to a file specified by the '-o' or '--output-file' option.

    Example usage:
    - Check a single site:
      python cve_2020_35489_checker.py -d example.com

    - Check multiple sites from a text file:
      python cve_2020_35489_checker.py -i list.txt -o vulnerable.txt
    """

    parser = argparse.ArgumentParser(
        description='Checks if a WordPress website is vulnerable to CVE-2020-35489.'
    )
    parser.add_argument('-d', '--domain', help='Check a single site (Example: python cve_2020_35489_checker.py -d example.com)')
    parser.add_argument('-i', '--input-file', help='Check multiple sites from a text file (Example: python cve_2020_35489_checker.py -i list.txt -o vulnerable.txt)')
    parser.add_argument('-o', '--output-file', help='Output file for the list of vulnerable sites')
    args = parser.parse_args()

    # If the output file is specified on the command line but does not exist, it is created
    if args.output_file and not os.path.exists(args.output_file):
        open(args.output_file, 'w').close()

    if args.input_file:
        if not os.path.exists(args.input_file):
            open(args.input_file, 'w').close()
            # If the input file is specified on the command line but does not exist, it is created empty and a message is showed to the user
            print(f"\nThe input file '{args.input_file}' was created in the current directory '{os.getcwd()}', but it is empty.\nPlease populate it with a list of sites to test and then try again.\n")
        else:
            async with aiohttp.ClientSession() as session:
                async with aiofiles.open(args.input_file, 'r') as f:
                    lines = await f.readlines()
                    tasks = [
                        check_site(session, line.strip(), args.output_file)
                        for line in lines if line.strip()
                    ]
                    await asyncio.gather(*tasks)
    elif args.domain:
        async with aiohttp.ClientSession() as session:
            await check_site(session, args.domain, args.output_file)
    else:
        parser.print_help()


asyncio.run(main())